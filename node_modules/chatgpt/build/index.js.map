{"version":3,"sources":["../src/chatgpt-api.ts","../src/types.ts","../src/chatgpt-conversation.ts","../src/fetch.ts","../src/fetch-sse.ts","../src/stream-async-iterable.ts","../src/utils.ts","../src/chatgpt-api-browser.ts","../src/openai-auth.ts"],"sourcesContent":["import ExpiryMap from 'expiry-map'\nimport pTimeout from 'p-timeout'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as types from './types'\nimport { ChatGPTConversation } from './chatgpt-conversation'\nimport { fetch } from './fetch'\nimport { fetchSSE } from './fetch-sse'\nimport { markdownToText } from './utils'\n\nconst KEY_ACCESS_TOKEN = 'accessToken'\nconst USER_AGENT =\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'\n\nexport class ChatGPTAPI {\n  protected _sessionToken: string\n  protected _clearanceToken: string\n  protected _markdown: boolean\n  protected _debug: boolean\n  protected _apiBaseUrl: string\n  protected _backendApiBaseUrl: string\n  protected _userAgent: string\n  protected _headers: Record<string, string>\n  protected _user: types.User | null = null\n\n  // Stores access tokens for `accessTokenTTL` milliseconds before needing to refresh\n  protected _accessTokenCache: ExpiryMap<string, string>\n\n  /**\n   * Creates a new client wrapper around the unofficial ChatGPT REST API.\n   *\n   * Note that your IP address and `userAgent` must match the same values that you used\n   * to obtain your `clearanceToken`.\n   *\n   * @param opts.sessionToken = **Required** OpenAI session token which can be found in a valid session's cookies (see readme for instructions)\n   * @param opts.clearanceToken = **Required** Cloudflare `cf_clearance` cookie value (see readme for instructions)\n   * @param apiBaseUrl - Optional override; the base URL for ChatGPT webapp's API (`/api`)\n   * @param backendApiBaseUrl - Optional override; the base URL for the ChatGPT backend API (`/backend-api`)\n   * @param userAgent - Optional override; the `user-agent` header to use with ChatGPT requests\n   * @param accessTokenTTL - Optional override; how long in milliseconds access tokens should last before being forcefully refreshed\n   * @param accessToken - Optional default access token if you already have a valid one generated\n   * @param heaaders - Optional additional HTTP headers to be added to each `fetch` request\n   * @param debug - Optional enables logging debugging into to stdout\n   */\n  constructor(opts: {\n    sessionToken: string\n\n    clearanceToken: string\n\n    /** @defaultValue `true` **/\n    markdown?: boolean\n\n    /** @defaultValue `'https://chat.openai.com/api'` **/\n    apiBaseUrl?: string\n\n    /** @defaultValue `'https://chat.openai.com/backend-api'` **/\n    backendApiBaseUrl?: string\n\n    /** @defaultValue `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'` **/\n    userAgent?: string\n\n    /** @defaultValue 1 hour **/\n    accessTokenTTL?: number\n\n    /** @defaultValue `undefined` **/\n    accessToken?: string\n\n    /** @defaultValue `undefined` **/\n    headers?: Record<string, string>\n\n    /** @defaultValue `false` **/\n    debug?: boolean\n  }) {\n    const {\n      sessionToken,\n      clearanceToken,\n      markdown = true,\n      apiBaseUrl = 'https://chat.openai.com/api',\n      backendApiBaseUrl = 'https://chat.openai.com/backend-api',\n      userAgent = USER_AGENT,\n      accessTokenTTL = 60 * 60000, // 1 hour\n      accessToken,\n      headers,\n      debug = false\n    } = opts\n\n    this._sessionToken = sessionToken\n    this._clearanceToken = clearanceToken\n    this._markdown = !!markdown\n    this._debug = !!debug\n    this._apiBaseUrl = apiBaseUrl\n    this._backendApiBaseUrl = backendApiBaseUrl\n    this._userAgent = userAgent\n    this._headers = {\n      'user-agent': this._userAgent,\n      'x-openai-assistant-app-id': '',\n      'accept-language': 'en-US,en;q=0.9',\n      'accept-encoding': 'gzip, deflate, br',\n      origin: 'https://chat.openai.com',\n      referer: 'https://chat.openai.com/chat',\n      'sec-ch-ua':\n        '\"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\", \"Google Chrome\";v=\"108\"',\n      'sec-ch-ua-platform': '\"macOS\"',\n      'sec-fetch-dest': 'empty',\n      'sec-fetch-mode': 'cors',\n      'sec-fetch-site': 'same-origin',\n      ...headers\n    }\n\n    this._accessTokenCache = new ExpiryMap<string, string>(accessTokenTTL)\n    if (accessToken) {\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\n    }\n\n    if (!this._sessionToken) {\n      throw new types.ChatGPTError('ChatGPT invalid session token')\n    }\n\n    if (!this._clearanceToken) {\n      throw new types.ChatGPTError('ChatGPT invalid clearance token')\n    }\n  }\n\n  /**\n   * Gets the currently signed-in user, if authenticated, `null` otherwise.\n   */\n  get user() {\n    return this._user\n  }\n\n  /** Gets the current session token. */\n  get sessionToken() {\n    return this._sessionToken\n  }\n\n  /** Gets the current Cloudflare clearance token (`cf_clearance` cookie value). */\n  get clearanceToken() {\n    return this._clearanceToken\n  }\n\n  /** Gets the current user agent. */\n  get userAgent() {\n    return this._userAgent\n  }\n\n  /**\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\n   * the response.\n   *\n   * If you want to receive a stream of partial responses, use `opts.onProgress`.\n   * If you want to receive the full response, including message and conversation IDs,\n   * you can use `opts.onConversationResponse` or use the `ChatGPTAPI.getConversation`\n   * helper.\n   *\n   * @param message - The prompt message to send\n   * @param opts.conversationId - Optional ID of a conversation to continue\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\n   * @param opts.messageId - Optional ID of the message to send (defaults to a random UUID)\n   * @param opts.action - Optional ChatGPT `action` (either `next` or `variant`)\n   * @param opts.timeoutMs - Optional timeout in milliseconds (defaults to no timeout)\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\n   * @param opts.onConversationResponse - Optional callback which will be invoked every time the partial response is updated with the full conversation response\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n   *\n   * @returns The response from ChatGPT\n   */\n  async sendMessage(\n    message: string,\n    opts: types.SendMessageOptions = {}\n  ): Promise<string> {\n    const {\n      conversationId,\n      parentMessageId = uuidv4(),\n      messageId = uuidv4(),\n      action = 'next',\n      timeoutMs,\n      onProgress,\n      onConversationResponse\n    } = opts\n\n    let { abortSignal } = opts\n\n    let abortController: AbortController = null\n    if (timeoutMs && !abortSignal) {\n      abortController = new AbortController()\n      abortSignal = abortController.signal\n    }\n\n    const accessToken = await this.refreshAccessToken()\n\n    const body: types.ConversationJSONBody = {\n      action,\n      messages: [\n        {\n          id: messageId,\n          role: 'user',\n          content: {\n            content_type: 'text',\n            parts: [message]\n          }\n        }\n      ],\n      model: 'text-davinci-002-render',\n      parent_message_id: parentMessageId\n    }\n\n    if (conversationId) {\n      body.conversation_id = conversationId\n    }\n\n    let response = ''\n\n    const responseP = new Promise<string>((resolve, reject) => {\n      const url = `${this._backendApiBaseUrl}/conversation`\n      const headers = {\n        ...this._headers,\n        Authorization: `Bearer ${accessToken}`,\n        Accept: 'text/event-stream',\n        'Content-Type': 'application/json',\n        Cookie: `cf_clearance=${this._clearanceToken}`\n      }\n\n      if (this._debug) {\n        console.log('POST', url, { body, headers })\n      }\n\n      fetchSSE(url, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body),\n        signal: abortSignal,\n        onMessage: (data: string) => {\n          if (data === '[DONE]') {\n            return resolve(response)\n          }\n\n          try {\n            const parsedData: types.ConversationResponseEvent = JSON.parse(data)\n            if (onConversationResponse) {\n              onConversationResponse(parsedData)\n            }\n\n            const message = parsedData.message\n            // console.log('event', JSON.stringify(parsedData, null, 2))\n\n            if (message) {\n              let text = message?.content?.parts?.[0]\n\n              if (text) {\n                if (!this._markdown) {\n                  text = markdownToText(text)\n                }\n\n                response = text\n\n                if (onProgress) {\n                  onProgress(text)\n                }\n              }\n            }\n          } catch (err) {\n            console.warn('fetchSSE onMessage unexpected error', err)\n            reject(err)\n          }\n        }\n      }).catch((err) => {\n        const errMessageL = err.toString().toLowerCase()\n\n        if (\n          response &&\n          (errMessageL === 'error: typeerror: terminated' ||\n            errMessageL === 'typeerror: terminated')\n        ) {\n          // OpenAI sometimes forcefully terminates the socket from their end before\n          // the HTTP request has resolved cleanly. In my testing, these cases tend to\n          // happen when OpenAI has already send the last `response`, so we can ignore\n          // the `fetch` error in this case.\n          return resolve(response)\n        } else {\n          return reject(err)\n        }\n      })\n    })\n\n    if (timeoutMs) {\n      if (abortController) {\n        // This will be called when a timeout occurs in order for us to forcibly\n        // ensure that the underlying HTTP request is aborted.\n        ;(responseP as any).cancel = () => {\n          abortController.abort()\n        }\n      }\n\n      return pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'ChatGPT timed out waiting for response'\n      })\n    } else {\n      return responseP\n    }\n  }\n\n  async sendModeration(input: string) {\n    const accessToken = await this.refreshAccessToken()\n    const url = `${this._backendApiBaseUrl}/moderations`\n    const headers = {\n      ...this._headers,\n      Authorization: `Bearer ${accessToken}`,\n      Accept: '*/*',\n      'Content-Type': 'application/json',\n      Cookie: `cf_clearance=${this._clearanceToken}`\n    }\n\n    const body: types.ModerationsJSONBody = {\n      input,\n      model: 'text-moderation-playground'\n    }\n\n    if (this._debug) {\n      console.log('POST', url, headers, body)\n    }\n\n    const res = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body)\n    }).then((r) => {\n      if (!r.ok) {\n        const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\n        error.response = r\n        error.statusCode = r.status\n        error.statusText = r.statusText\n        throw error\n      }\n\n      return r.json() as any as types.ModerationsJSONResult\n    })\n\n    return res\n  }\n\n  /**\n   * @returns `true` if the client has a valid acces token or `false` if refreshing\n   * the token fails.\n   */\n  async getIsAuthenticated() {\n    try {\n      void (await this.refreshAccessToken())\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  /**\n   * Refreshes the client's access token which will succeed only if the session\n   * is still valid.\n   */\n  async ensureAuth() {\n    return await this.refreshAccessToken()\n  }\n\n  /**\n   * Attempts to refresh the current access token using the ChatGPT\n   * `sessionToken` cookie.\n   *\n   * Access tokens will be cached for up to `accessTokenTTL` milliseconds to\n   * prevent refreshing access tokens too frequently.\n   *\n   * @returns A valid access token\n   * @throws An error if refreshing the access token fails.\n   */\n  async refreshAccessToken(): Promise<string> {\n    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN)\n    if (cachedAccessToken) {\n      return cachedAccessToken\n    }\n\n    let response: Response\n    try {\n      const url = `${this._apiBaseUrl}/auth/session`\n      const headers = {\n        ...this._headers,\n        cookie: `cf_clearance=${this._clearanceToken}; __Secure-next-auth.session-token=${this._sessionToken}`,\n        accept: '*/*'\n      }\n\n      if (this._debug) {\n        console.log('GET', url, headers)\n      }\n\n      const res = await fetch(url, {\n        headers\n      }).then((r) => {\n        response = r\n\n        if (!r.ok) {\n          const error = new types.ChatGPTError(`${r.status} ${r.statusText}`)\n          error.response = r\n          error.statusCode = r.status\n          error.statusText = r.statusText\n          throw error\n        }\n\n        return r.json() as any as types.SessionResult\n      })\n\n      const accessToken = res?.accessToken\n\n      if (!accessToken) {\n        const error = new types.ChatGPTError('Unauthorized')\n        error.response = response\n        error.statusCode = response?.status\n        error.statusText = response?.statusText\n        throw error\n      }\n\n      const appError = res?.error\n      if (appError) {\n        if (appError === 'RefreshAccessTokenError') {\n          const error = new types.ChatGPTError('session token may have expired')\n          error.response = response\n          error.statusCode = response?.status\n          error.statusText = response?.statusText\n          throw error\n        } else {\n          const error = new types.ChatGPTError(appError)\n          error.response = response\n          error.statusCode = response?.status\n          error.statusText = response?.statusText\n          throw error\n        }\n      }\n\n      if (res.user) {\n        this._user = res.user\n      }\n\n      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken)\n      return accessToken\n    } catch (err: any) {\n      if (this._debug) {\n        console.error(err)\n      }\n\n      const error = new types.ChatGPTError(\n        `ChatGPT failed to refresh auth token. ${err.toString()}`\n      )\n      error.response = response\n      error.statusCode = response?.status\n      error.statusText = response?.statusText\n      error.originalError = err\n      throw error\n    }\n  }\n\n  /**\n   * Gets a new ChatGPTConversation instance, which can be used to send multiple\n   * messages as part of a single conversation.\n   *\n   * @param opts.conversationId - Optional ID of the previous message in a conversation\n   * @param opts.parentMessageId - Optional ID of the previous message in a conversation\n   * @returns The new conversation instance\n   */\n  getConversation(\n    opts: { conversationId?: string; parentMessageId?: string } = {}\n  ) {\n    return new ChatGPTConversation(this, opts)\n  }\n}\n","export type ContentType = 'text'\n\nexport type Role = 'user' | 'assistant'\n\n/**\n * https://chat.openapi.com/api/auth/session\n */\nexport type SessionResult = {\n  /**\n   * Authenticated user\n   */\n  user: User\n\n  /**\n   * ISO date of the expiration date of the access token\n   */\n  expires: string\n\n  /**\n   * The access token\n   */\n  accessToken: string\n\n  /**\n   * If there was an error associated with this request\n   */\n  error?: string | null\n}\n\nexport type User = {\n  /**\n   * ID of the user\n   */\n  id: string\n\n  /**\n   * Name of the user\n   */\n  name: string\n\n  /**\n   * Email of the user\n   */\n  email?: string\n\n  /**\n   * Image of the user\n   */\n  image: string\n\n  /**\n   * Picture of the user\n   */\n  picture: string\n\n  /**\n   * Groups the user is in\n   */\n  groups: string[]\n\n  /**\n   * Features the user is in\n   */\n  features: string[]\n}\n\n/**\n * https://chat.openapi.com/backend-api/models\n */\nexport type ModelsResult = {\n  /**\n   * Array of models\n   */\n  models: Model[]\n}\n\nexport type Model = {\n  /**\n   * Name of the model\n   */\n  slug: string\n\n  /**\n   * Max tokens of the model\n   */\n  max_tokens: number\n\n  /**\n   * Whether or not the model is special\n   */\n  is_special: boolean\n}\n\n/**\n * https://chat.openapi.com/backend-api/moderations\n */\nexport type ModerationsJSONBody = {\n  /**\n   * Input for the moderation decision\n   */\n  input: string\n\n  /**\n   * The model to use in the decision\n   */\n  model: AvailableModerationModels\n}\n\nexport type AvailableModerationModels = 'text-moderation-playground'\n\n/**\n * https://chat.openapi.com/backend-api/moderations\n */\nexport type ModerationsJSONResult = {\n  /**\n   * Whether or not the input is flagged\n   */\n  flagged: boolean\n\n  /**\n   * Whether or not the input is blocked\n   */\n  blocked: boolean\n\n  /**\n   * The ID of the decision\n   */\n  moderation_id: string\n}\n\n/**\n * https://chat.openapi.com/backend-api/conversation\n */\nexport type ConversationJSONBody = {\n  /**\n   * The action to take\n   */\n  action: string\n\n  /**\n   * The ID of the conversation\n   */\n  conversation_id?: string\n\n  /**\n   * Prompts to provide\n   */\n  messages: Prompt[]\n\n  /**\n   * The model to use\n   */\n  model: string\n\n  /**\n   * The parent message ID\n   */\n  parent_message_id: string\n}\n\nexport type Prompt = {\n  /**\n   * The content of the prompt\n   */\n  content: PromptContent\n\n  /**\n   * The ID of the prompt\n   */\n  id: string\n\n  /**\n   * The role played in the prompt\n   */\n  role: Role\n}\n\nexport type PromptContent = {\n  /**\n   * The content type of the prompt\n   */\n  content_type: ContentType\n\n  /**\n   * The parts to the prompt\n   */\n  parts: string[]\n}\n\n/**\n * https://chat.openapi.com/backend-api/conversation/message_feedback\n */\nexport type MessageFeedbackJSONBody = {\n  /**\n   * The ID of the conversation\n   */\n  conversation_id: string\n\n  /**\n   * The message ID\n   */\n  message_id: string\n\n  /**\n   * The rating\n   */\n  rating: MessageFeedbackRating\n\n  /**\n   * Tags to give the rating\n   */\n  tags?: MessageFeedbackTags[]\n\n  /**\n   * The text to include\n   */\n  text?: string\n}\n\nexport type MessageFeedbackTags = 'harmful' | 'false' | 'not-helpful'\n\nexport type MessageFeedbackResult = {\n  /**\n   * The message ID\n   */\n  message_id: string\n\n  /**\n   * The ID of the conversation\n   */\n  conversation_id: string\n\n  /**\n   * The ID of the user\n   */\n  user_id: string\n\n  /**\n   * The rating\n   */\n  rating: MessageFeedbackRating\n\n  /**\n   * The text the server received, including tags\n   */\n  text?: string\n}\n\nexport type MessageFeedbackRating = 'thumbsUp' | 'thumbsDown'\n\nexport type ConversationResponseEvent = {\n  message?: Message\n  conversation_id?: string\n  error?: string | null\n}\n\nexport type Message = {\n  id: string\n  content: MessageContent\n  role: string\n  user: string | null\n  create_time: string | null\n  update_time: string | null\n  end_turn: null\n  weight: number\n  recipient: string\n  metadata: MessageMetadata\n}\n\nexport type MessageContent = {\n  content_type: string\n  parts: string[]\n}\n\nexport type MessageMetadata = any\nexport type MessageActionType = 'next' | 'variant'\n\nexport type SendMessageOptions = {\n  conversationId?: string\n  parentMessageId?: string\n  messageId?: string\n  action?: MessageActionType\n  timeoutMs?: number\n  onProgress?: (partialResponse: string) => void\n  onConversationResponse?: (response: ConversationResponseEvent) => void\n  abortSignal?: AbortSignal\n}\n\nexport type SendConversationMessageOptions = Omit<\n  SendMessageOptions,\n  'conversationId' | 'parentMessageId'\n>\n\nexport class ChatGPTError extends Error {\n  statusCode?: number\n  statusText?: string\n  response?: Response\n  originalError?: Error\n}\n\nexport type ChatError = {\n  error: { message: string; statusCode?: number; statusText?: string }\n  response: null\n  conversationId?: string\n  messageId?: string\n  conversationResponse?: ConversationResponseEvent\n}\n\nexport type ChatResponse = {\n  error: null\n  response: string\n  conversationId: string\n  messageId: string\n  conversationResponse?: ConversationResponseEvent\n}\n","import * as types from './types'\nimport { type ChatGPTAPI } from './chatgpt-api'\n\n/**\n * A conversation wrapper around the ChatGPTAPI. This allows you to send\n * multiple messages to ChatGPT and receive responses, without having to\n * manually pass the conversation ID and parent message ID for each message.\n */\nexport class ChatGPTConversation {\n  api: ChatGPTAPI\n  conversationId: string = undefined\n  parentMessageId: string = undefined\n\n  /**\n   * Creates a new conversation wrapper around the ChatGPT API.\n   *\n   * @param api - The ChatGPT API instance to use\n   * @param opts.conversationId - Optional ID of a conversation to continue\n   * @param opts.parentMessageId - Optional ID of the previous message in the conversation\n   */\n  constructor(\n    api: ChatGPTAPI,\n    opts: { conversationId?: string; parentMessageId?: string } = {}\n  ) {\n    this.api = api\n    this.conversationId = opts.conversationId\n    this.parentMessageId = opts.parentMessageId\n  }\n\n  /**\n   * Sends a message to ChatGPT, waits for the response to resolve, and returns\n   * the response.\n   *\n   * If this is the first message in the conversation, the conversation ID and\n   * parent message ID will be automatically set.\n   *\n   * This allows you to send multiple messages to ChatGPT and receive responses,\n   * without having to manually pass the conversation ID and parent message ID\n   * for each message.\n   *\n   * @param message - The prompt message to send\n   * @param opts.onProgress - Optional callback which will be invoked every time the partial response is updated\n   * @param opts.onConversationResponse - Optional callback which will be invoked every time the partial response is updated with the full conversation response\n   * @param opts.abortSignal - Optional callback used to abort the underlying `fetch` call using an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n   *\n   * @returns The response from ChatGPT\n   */\n  async sendMessage(\n    message: string,\n    opts: types.SendConversationMessageOptions = {}\n  ): Promise<string> {\n    const { onConversationResponse, ...rest } = opts\n\n    return this.api.sendMessage(message, {\n      ...rest,\n      conversationId: this.conversationId,\n      parentMessageId: this.parentMessageId,\n      onConversationResponse: (response) => {\n        if (response.conversation_id) {\n          this.conversationId = response.conversation_id\n        }\n\n        if (response.message?.id) {\n          this.parentMessageId = response.message.id\n        }\n\n        if (onConversationResponse) {\n          return onConversationResponse(response)\n        }\n      }\n    })\n  }\n}\n","/// <reference lib=\"dom\" />\n\n// Use `fetch` for node.js >= 18\n// Use `fetch` for all other environments, including browsers\nconst fetch = globalThis.fetch\n\nif (typeof fetch !== 'function') {\n  throw new Error(\n    'Invalid environment: global fetch not defined; `chatgpt` requires Node.js >= 18 at the moment due to Cloudflare protections'\n  )\n}\n\nexport { fetch }\n","import { createParser } from 'eventsource-parser'\n\nimport * as types from './types'\nimport { fetch } from './fetch'\nimport { streamAsyncIterable } from './stream-async-iterable'\n\nexport async function fetchSSE(\n  url: string,\n  options: Parameters<typeof fetch>[1] & { onMessage: (data: string) => void }\n) {\n  const { onMessage, ...fetchOptions } = options\n  const res = await fetch(url, fetchOptions)\n  if (!res.ok) {\n    const msg = `ChatGPTAPI error ${res.status || res.statusText}`\n    const error = new types.ChatGPTError(msg)\n    error.statusCode = res.status\n    error.statusText = res.statusText\n    error.response = res\n    throw error\n  }\n\n  const parser = createParser((event) => {\n    if (event.type === 'event') {\n      onMessage(event.data)\n    }\n  })\n\n  if (!res.body.getReader) {\n    // Vercel polyfills `fetch` with `node-fetch`, which doesn't conform to\n    // web standards, so this is a workaround...\n    const body: NodeJS.ReadableStream = res.body as any\n\n    if (!body.on || !body.read) {\n      throw new types.ChatGPTError('unsupported \"fetch\" implementation')\n    }\n\n    body.on('readable', () => {\n      let chunk: string | Buffer\n      while (null !== (chunk = body.read())) {\n        parser.feed(chunk.toString())\n      }\n    })\n  } else {\n    for await (const chunk of streamAsyncIterable(res.body)) {\n      const str = new TextDecoder().decode(chunk)\n      parser.feed(str)\n    }\n  }\n}\n","export async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\n  const reader = stream.getReader()\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) {\n        return\n      }\n      yield value\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n","import type * as PTimeoutTypes from 'p-timeout'\nimport type {\n  EventSourceParseCallback,\n  EventSourceParser\n} from 'eventsource-parser'\nimport type { Page } from 'puppeteer'\nimport { remark } from 'remark'\nimport stripMarkdown from 'strip-markdown'\n\nimport * as types from './types'\n\nexport function markdownToText(markdown?: string): string {\n  return remark()\n    .use(stripMarkdown)\n    .processSync(markdown ?? '')\n    .toString()\n}\n\nexport async function minimizePage(page: Page) {\n  const session = await page.target().createCDPSession()\n  const goods = await session.send('Browser.getWindowForTarget')\n  const { windowId } = goods\n  await session.send('Browser.setWindowBounds', {\n    windowId,\n    bounds: { windowState: 'minimized' }\n  })\n}\n\nexport async function maximizePage(page: Page) {\n  const session = await page.target().createCDPSession()\n  const goods = await session.send('Browser.getWindowForTarget')\n  const { windowId } = goods\n  await session.send('Browser.setWindowBounds', {\n    windowId,\n    bounds: { windowState: 'normal' }\n  })\n}\n\nexport function isRelevantRequest(url: string): boolean {\n  let pathname\n\n  try {\n    const parsedUrl = new URL(url)\n    pathname = parsedUrl.pathname\n    url = parsedUrl.toString()\n  } catch (_) {\n    return false\n  }\n\n  if (!url.startsWith('https://chat.openai.com')) {\n    return false\n  }\n\n  if (\n    !pathname.startsWith('/backend-api/') &&\n    !pathname.startsWith('/api/auth/session')\n  ) {\n    return false\n  }\n\n  if (pathname.endsWith('backend-api/moderations')) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * This function is injected into the ChatGPT webapp page using puppeteer. It\n * has to be fully self-contained, so we copied a few third-party sources and\n * included them in here.\n */\nexport async function browserPostEventStream(\n  url: string,\n  accessToken: string,\n  body: types.ConversationJSONBody,\n  timeoutMs?: number\n): Promise<types.ChatError | types.ChatResponse> {\n  // Workaround for https://github.com/esbuild-kit/tsx/issues/113\n  globalThis.__name = () => undefined\n\n  class TimeoutError extends Error {\n    readonly name: 'TimeoutError'\n\n    constructor(message) {\n      super(message)\n      this.name = 'TimeoutError'\n    }\n  }\n\n  /**\n    An error to be thrown when the request is aborted by AbortController.\n    DOMException is thrown instead of this Error when DOMException is available.\n  */\n  class AbortError extends Error {\n    constructor(message) {\n      super()\n      this.name = 'AbortError'\n      this.message = message\n    }\n  }\n\n  const BOM = [239, 187, 191]\n\n  let conversationResponse: types.ConversationResponseEvent\n  let conversationId: string = body?.conversation_id\n  let messageId: string = body?.messages?.[0]?.id\n  let response = ''\n\n  try {\n    console.log('browserPostEventStream', url, accessToken, body)\n\n    let abortController: AbortController = null\n    if (timeoutMs) {\n      abortController = new AbortController()\n    }\n\n    const res = await fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(body),\n      signal: abortController?.signal,\n      headers: {\n        accept: 'text/event-stream',\n        'x-openai-assistant-app-id': '',\n        authorization: `Bearer ${accessToken}`,\n        'content-type': 'application/json'\n      }\n    })\n\n    console.log('browserPostEventStream response', res)\n\n    if (!res.ok) {\n      return {\n        error: {\n          message: `ChatGPTAPI error ${res.status || res.statusText}`,\n          statusCode: res.status,\n          statusText: res.statusText\n        },\n        response: null,\n        conversationId,\n        messageId\n      }\n    }\n\n    const responseP = new Promise<types.ChatResponse>(\n      async (resolve, reject) => {\n        function onMessage(data: string) {\n          if (data === '[DONE]') {\n            return resolve({\n              error: null,\n              response,\n              conversationId,\n              messageId,\n              conversationResponse\n            })\n          }\n\n          try {\n            const convoResponseEvent: types.ConversationResponseEvent =\n              JSON.parse(data)\n            conversationResponse = convoResponseEvent\n            if (convoResponseEvent.conversation_id) {\n              conversationId = convoResponseEvent.conversation_id\n            }\n\n            if (convoResponseEvent.message?.id) {\n              messageId = convoResponseEvent.message.id\n            }\n\n            const partialResponse =\n              convoResponseEvent.message?.content?.parts?.[0]\n            if (partialResponse) {\n              response = partialResponse\n            }\n          } catch (err) {\n            console.warn('fetchSSE onMessage unexpected error', err)\n            reject(err)\n          }\n        }\n\n        const parser = createParser((event) => {\n          if (event.type === 'event') {\n            onMessage(event.data)\n          }\n        })\n\n        for await (const chunk of streamAsyncIterable(res.body)) {\n          const str = new TextDecoder().decode(chunk)\n          parser.feed(str)\n        }\n      }\n    )\n\n    if (timeoutMs) {\n      if (abortController) {\n        // This will be called when a timeout occurs in order for us to forcibly\n        // ensure that the underlying HTTP request is aborted.\n        ;(responseP as any).cancel = () => {\n          abortController.abort()\n        }\n      }\n\n      return await pTimeout(responseP, {\n        milliseconds: timeoutMs,\n        message: 'ChatGPT timed out waiting for response'\n      })\n    } else {\n      return await responseP\n    }\n  } catch (err) {\n    const errMessageL = err.toString().toLowerCase()\n\n    if (\n      response &&\n      (errMessageL === 'error: typeerror: terminated' ||\n        errMessageL === 'typeerror: terminated')\n    ) {\n      // OpenAI sometimes forcefully terminates the socket from their end before\n      // the HTTP request has resolved cleanly. In my testing, these cases tend to\n      // happen when OpenAI has already send the last `response`, so we can ignore\n      // the `fetch` error in this case.\n      return {\n        error: null,\n        response,\n        conversationId,\n        messageId,\n        conversationResponse\n      }\n    }\n\n    return {\n      error: {\n        message: err.toString(),\n        statusCode: err.statusCode || err.status || err.response?.statusCode,\n        statusText: err.statusText || err.response?.statusText\n      },\n      response: null,\n      conversationId,\n      messageId,\n      conversationResponse\n    }\n  }\n\n  async function* streamAsyncIterable<T>(stream: ReadableStream<T>) {\n    const reader = stream.getReader()\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          return\n        }\n        yield value\n      }\n    } finally {\n      reader.releaseLock()\n    }\n  }\n\n  // @see https://github.com/rexxars/eventsource-parser\n  function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n    // Processing state\n    let isFirstChunk: boolean\n    let buffer: string\n    let startingPosition: number\n    let startingFieldLength: number\n\n    // Event state\n    let eventId: string | undefined\n    let eventName: string | undefined\n    let data: string\n\n    reset()\n    return { feed, reset }\n\n    function reset(): void {\n      isFirstChunk = true\n      buffer = ''\n      startingPosition = 0\n      startingFieldLength = -1\n\n      eventId = undefined\n      eventName = undefined\n      data = ''\n    }\n\n    function feed(chunk: string): void {\n      buffer = buffer ? buffer + chunk : chunk\n\n      // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n      // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n      // always decoded as UTF8 as per the specification.\n      if (isFirstChunk && hasBom(buffer)) {\n        buffer = buffer.slice(BOM.length)\n      }\n\n      isFirstChunk = false\n\n      // Set up chunk-specific processing state\n      const length = buffer.length\n      let position = 0\n      let discardTrailingNewline = false\n\n      // Read the current buffer byte by byte\n      while (position < length) {\n        // EventSource allows for carriage return + line feed, which means we\n        // need to ignore a linefeed character if the previous character was a\n        // carriage return\n        // @todo refactor to reduce nesting, consider checking previous byte?\n        // @todo but consider multiple chunks etc\n        if (discardTrailingNewline) {\n          if (buffer[position] === '\\n') {\n            ++position\n          }\n          discardTrailingNewline = false\n        }\n\n        let lineLength = -1\n        let fieldLength = startingFieldLength\n        let character: string\n\n        for (\n          let index = startingPosition;\n          lineLength < 0 && index < length;\n          ++index\n        ) {\n          character = buffer[index]\n          if (character === ':' && fieldLength < 0) {\n            fieldLength = index - position\n          } else if (character === '\\r') {\n            discardTrailingNewline = true\n            lineLength = index - position\n          } else if (character === '\\n') {\n            lineLength = index - position\n          }\n        }\n\n        if (lineLength < 0) {\n          startingPosition = length - position\n          startingFieldLength = fieldLength\n          break\n        } else {\n          startingPosition = 0\n          startingFieldLength = -1\n        }\n\n        parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n        position += lineLength + 1\n      }\n\n      if (position === length) {\n        // If we consumed the entire buffer to read the event, reset the buffer\n        buffer = ''\n      } else if (position > 0) {\n        // If there are bytes left to process, set the buffer to the unprocessed\n        // portion of the buffer only\n        buffer = buffer.slice(position)\n      }\n    }\n\n    function parseEventStreamLine(\n      lineBuffer: string,\n      index: number,\n      fieldLength: number,\n      lineLength: number\n    ) {\n      if (lineLength === 0) {\n        // We reached the last line of this event\n        if (data.length > 0) {\n          onParse({\n            type: 'event',\n            id: eventId,\n            event: eventName || undefined,\n            data: data.slice(0, -1) // remove trailing newline\n          })\n\n          data = ''\n          eventId = undefined\n        }\n        eventName = undefined\n        return\n      }\n\n      const noValue = fieldLength < 0\n      const field = lineBuffer.slice(\n        index,\n        index + (noValue ? lineLength : fieldLength)\n      )\n      let step = 0\n\n      if (noValue) {\n        step = lineLength\n      } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n        step = fieldLength + 2\n      } else {\n        step = fieldLength + 1\n      }\n\n      const position = index + step\n      const valueLength = lineLength - step\n      const value = lineBuffer\n        .slice(position, position + valueLength)\n        .toString()\n\n      if (field === 'data') {\n        data += value ? `${value}\\n` : '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id' && !value.includes('\\u0000')) {\n        eventId = value\n      } else if (field === 'retry') {\n        const retry = parseInt(value, 10)\n        if (!Number.isNaN(retry)) {\n          onParse({ type: 'reconnect-interval', value: retry })\n        }\n      }\n    }\n  }\n\n  function hasBom(buffer: string) {\n    return BOM.every(\n      (charCode: number, index: number) => buffer.charCodeAt(index) === charCode\n    )\n  }\n\n  /**\n    TODO: Remove AbortError and just throw DOMException when targeting Node 18.\n   */\n  function getDOMException(errorMessage) {\n    return globalThis.DOMException === undefined\n      ? new AbortError(errorMessage)\n      : new DOMException(errorMessage)\n  }\n\n  /**\n    TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n   */\n  function getAbortedReason(signal) {\n    const reason =\n      signal.reason === undefined\n        ? getDOMException('This operation was aborted.')\n        : signal.reason\n\n    return reason instanceof Error ? reason : getDOMException(reason)\n  }\n\n  // @see https://github.com/sindresorhus/p-timeout\n  function pTimeout<ValueType, ReturnType = ValueType>(\n    promise: PromiseLike<ValueType>,\n    options: PTimeoutTypes.Options<ReturnType>\n  ): PTimeoutTypes.ClearablePromise<ValueType | ReturnType> {\n    const {\n      milliseconds,\n      fallback,\n      message,\n      customTimers = { setTimeout, clearTimeout }\n    } = options\n\n    let timer\n\n    const cancelablePromise = new Promise((resolve, reject) => {\n      if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n        throw new TypeError(\n          `Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``\n        )\n      }\n\n      if (milliseconds === Number.POSITIVE_INFINITY) {\n        resolve(promise)\n        return\n      }\n\n      if (options.signal) {\n        const { signal } = options\n        if (signal.aborted) {\n          reject(getAbortedReason(signal))\n        }\n\n        signal.addEventListener('abort', () => {\n          reject(getAbortedReason(signal))\n        })\n      }\n\n      timer = customTimers.setTimeout.call(\n        undefined,\n        () => {\n          if (fallback) {\n            try {\n              resolve(fallback())\n            } catch (error) {\n              reject(error)\n            }\n\n            return\n          }\n\n          const errorMessage =\n            typeof message === 'string'\n              ? message\n              : `Promise timed out after ${milliseconds} milliseconds`\n          const timeoutError =\n            message instanceof Error ? message : new TimeoutError(errorMessage)\n\n          if (typeof (promise as any).cancel === 'function') {\n            ;(promise as any).cancel()\n          }\n\n          reject(timeoutError)\n        },\n        milliseconds\n      )\n      ;(async () => {\n        try {\n          resolve(await promise)\n        } catch (error) {\n          reject(error)\n        } finally {\n          customTimers.clearTimeout.call(undefined, timer)\n        }\n      })()\n    })\n\n    ;(cancelablePromise as any).clear = () => {\n      customTimers.clearTimeout.call(undefined, timer)\n      timer = undefined\n    }\n\n    return cancelablePromise as any\n  }\n}\n","import delay from 'delay'\nimport type { Browser, HTTPRequest, HTTPResponse, Page } from 'puppeteer'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport * as types from './types'\nimport { getBrowser, getOpenAIAuth } from './openai-auth'\nimport {\n  browserPostEventStream,\n  isRelevantRequest,\n  maximizePage,\n  minimizePage\n} from './utils'\n\nexport class ChatGPTAPIBrowser {\n  protected _markdown: boolean\n  protected _debug: boolean\n  protected _minimize: boolean\n  protected _isGoogleLogin: boolean\n  protected _captchaToken: string\n  protected _accessToken: string\n\n  protected _email: string\n  protected _password: string\n\n  protected _executablePath: string\n  protected _browser: Browser\n  protected _page: Page\n\n  /**\n   * Creates a new client wrapper for automating the ChatGPT webapp.\n   */\n  constructor(opts: {\n    email: string\n    password: string\n\n    /** @defaultValue `true` **/\n    markdown?: boolean\n\n    /** @defaultValue `false` **/\n    debug?: boolean\n\n    /** @defaultValue `false` **/\n    isGoogleLogin?: boolean\n\n    /** @defaultValue `true` **/\n    minimize?: boolean\n\n    /** @defaultValue `undefined` **/\n    captchaToken?: string\n\n    /** @defaultValue `undefined` **/\n    executablePath?: string\n  }) {\n    const {\n      email,\n      password,\n      markdown = true,\n      debug = false,\n      isGoogleLogin = false,\n      minimize = true,\n      captchaToken,\n      executablePath\n    } = opts\n\n    this._email = email\n    this._password = password\n\n    this._markdown = !!markdown\n    this._debug = !!debug\n    this._isGoogleLogin = !!isGoogleLogin\n    this._minimize = !!minimize\n    this._captchaToken = captchaToken\n    this._executablePath = executablePath\n  }\n\n  async init() {\n    if (this._browser) {\n      await this._browser.close()\n      this._page = null\n      this._browser = null\n      this._accessToken = null\n    }\n\n    try {\n      this._browser = await getBrowser({\n        captchaToken: this._captchaToken,\n        executablePath: this._executablePath\n      })\n      this._page =\n        (await this._browser.pages())[0] || (await this._browser.newPage())\n\n      await maximizePage(this._page)\n\n      this._page.on('request', this._onRequest.bind(this))\n      this._page.on('response', this._onResponse.bind(this))\n\n      // bypass cloudflare and login\n      await getOpenAIAuth({\n        email: this._email,\n        password: this._password,\n        browser: this._browser,\n        page: this._page,\n        isGoogleLogin: this._isGoogleLogin\n      })\n    } catch (err) {\n      if (this._browser) {\n        await this._browser.close()\n      }\n\n      this._browser = null\n      this._page = null\n\n      throw err\n    }\n\n    const chatUrl = 'https://chat.openai.com/chat'\n    const url = this._page.url().replace(/\\/$/, '')\n\n    if (url !== chatUrl) {\n      await this._page.goto(chatUrl, {\n        waitUntil: 'networkidle2'\n      })\n    }\n\n    // dismiss welcome modal (and other modals)\n    do {\n      const modalSelector = '[data-headlessui-state=\"open\"]'\n\n      if (!(await this._page.$(modalSelector))) {\n        break\n      }\n\n      try {\n        await this._page.click(`${modalSelector} button:last-child`)\n      } catch (err) {\n        // \"next\" button not found in welcome modal\n        break\n      }\n\n      await delay(300)\n    } while (true)\n\n    if (!this.getIsAuthenticated()) {\n      return false\n    }\n\n    if (this._minimize) {\n      await minimizePage(this._page)\n    }\n\n    return true\n  }\n\n  _onRequest = (request: HTTPRequest) => {\n    const url = request.url()\n    if (!isRelevantRequest(url)) {\n      return\n    }\n\n    const method = request.method()\n    let body: any\n\n    if (method === 'POST') {\n      body = request.postData()\n\n      try {\n        body = JSON.parse(body)\n      } catch (_) {}\n\n      // if (url.endsWith('/conversation') && typeof body === 'object') {\n      //   const conversationBody: types.ConversationJSONBody = body\n      //   const conversationId = conversationBody.conversation_id\n      //   const parentMessageId = conversationBody.parent_message_id\n      //   const messageId = conversationBody.messages?.[0]?.id\n      //   const prompt = conversationBody.messages?.[0]?.content?.parts?.[0]\n\n      //   // TODO: store this info for the current sendMessage request\n      // }\n    }\n\n    if (this._debug) {\n      console.log('\\nrequest', {\n        url,\n        method,\n        headers: request.headers(),\n        body\n      })\n    }\n  }\n\n  _onResponse = async (response: HTTPResponse) => {\n    const request = response.request()\n\n    const url = response.url()\n    if (!isRelevantRequest(url)) {\n      return\n    }\n\n    const status = response.status()\n\n    let body: any\n    try {\n      body = await response.json()\n    } catch (_) {}\n\n    if (this._debug) {\n      console.log('\\nresponse', {\n        url,\n        ok: response.ok(),\n        status,\n        statusText: response.statusText(),\n        headers: response.headers(),\n        body,\n        request: {\n          method: request.method(),\n          headers: request.headers(),\n          body: request.postData()\n        }\n      })\n    }\n\n    if (url.endsWith('/conversation')) {\n      if (status === 403) {\n        await this.handle403Error()\n      }\n    } else if (url.endsWith('api/auth/session')) {\n      if (status === 403) {\n        await this.handle403Error()\n      } else {\n        const session: types.SessionResult = body\n\n        if (session?.accessToken) {\n          this._accessToken = session.accessToken\n        }\n      }\n    }\n  }\n\n  async handle403Error() {\n    console.log(`ChatGPT \"${this._email}\" session expired; refreshing...`)\n    try {\n      await maximizePage(this._page)\n      await this._page.reload({\n        waitUntil: 'networkidle2',\n        timeout: 2 * 60 * 1000 // 2 minutes\n      })\n      if (this._minimize) {\n        await minimizePage(this._page)\n      }\n    } catch (err) {\n      console.error(\n        `ChatGPT \"${this._email}\" error refreshing session`,\n        err.toString()\n      )\n    }\n  }\n\n  async getIsAuthenticated() {\n    try {\n      const inputBox = await this._getInputBox()\n      return !!inputBox\n    } catch (err) {\n      // can happen when navigating during login\n      return false\n    }\n  }\n\n  // async getLastMessage(): Promise<string | null> {\n  //   const messages = await this.getMessages()\n\n  //   if (messages) {\n  //     return messages[messages.length - 1]\n  //   } else {\n  //     return null\n  //   }\n  // }\n\n  // async getPrompts(): Promise<string[]> {\n  //   // Get all prompts\n  //   const messages = await this._page.$$(\n  //     '.text-base:has(.whitespace-pre-wrap):not(:has(button:nth-child(2))) .whitespace-pre-wrap'\n  //   )\n\n  //   // Prompts are always plaintext\n  //   return Promise.all(messages.map((a) => a.evaluate((el) => el.textContent)))\n  // }\n\n  // async getMessages(): Promise<string[]> {\n  //   // Get all complete messages\n  //   // (in-progress messages that are being streamed back don't contain action buttons)\n  //   const messages = await this._page.$$(\n  //     '.text-base:has(.whitespace-pre-wrap):has(button:nth-child(2)) .whitespace-pre-wrap'\n  //   )\n\n  //   if (this._markdown) {\n  //     const htmlMessages = await Promise.all(\n  //       messages.map((a) => a.evaluate((el) => el.innerHTML))\n  //     )\n\n  //     const markdownMessages = htmlMessages.map((messageHtml) => {\n  //       // parse markdown from message HTML\n  //       messageHtml = messageHtml\n  //         .replaceAll('Copy code</button>', '</button>')\n  //         .replace(/Copy code\\s*<\\/button>/gim, '</button>')\n\n  //       return html2md(messageHtml, {\n  //         ignoreTags: [\n  //           'button',\n  //           'svg',\n  //           'style',\n  //           'form',\n  //           'noscript',\n  //           'script',\n  //           'meta',\n  //           'head'\n  //         ],\n  //         skipTags: ['button', 'svg']\n  //       })\n  //     })\n\n  //     return markdownMessages\n  //   } else {\n  //     // plaintext\n  //     const plaintextMessages = await Promise.all(\n  //       messages.map((a) => a.evaluate((el) => el.textContent))\n  //     )\n  //     return plaintextMessages\n  //   }\n  // }\n\n  async sendMessage(\n    message: string,\n    opts: types.SendMessageOptions = {}\n  ): Promise<string> {\n    const {\n      conversationId,\n      parentMessageId = uuidv4(),\n      messageId = uuidv4(),\n      action = 'next',\n      // TODO\n      timeoutMs,\n      // onProgress,\n      onConversationResponse\n    } = opts\n\n    const inputBox = await this._getInputBox()\n    if (!inputBox || !this._accessToken) {\n      console.log(`chatgpt re-authenticating ${this._email}`)\n      let isAuthenticated = false\n\n      try {\n        isAuthenticated = await this.init()\n      } catch (err) {\n        console.warn(\n          `chatgpt error re-authenticating ${this._email}`,\n          err.toString()\n        )\n      }\n\n      if (!isAuthenticated || !this._accessToken) {\n        const error = new types.ChatGPTError('Not signed in')\n        error.statusCode = 401\n        throw error\n      }\n    }\n\n    const url = `https://chat.openai.com/backend-api/conversation`\n    const body: types.ConversationJSONBody = {\n      action,\n      messages: [\n        {\n          id: messageId,\n          role: 'user',\n          content: {\n            content_type: 'text',\n            parts: [message]\n          }\n        }\n      ],\n      model: 'text-davinci-002-render',\n      parent_message_id: parentMessageId\n    }\n\n    if (conversationId) {\n      body.conversation_id = conversationId\n    }\n\n    // console.log('>>> EVALUATE', url, this._accessToken, body)\n    const result = await this._page.evaluate(\n      browserPostEventStream,\n      url,\n      this._accessToken,\n      body,\n      timeoutMs\n    )\n    // console.log('<<< EVALUATE', result)\n\n    if (result.error) {\n      const error = new types.ChatGPTError(result.error.message)\n      error.statusCode = result.error.statusCode\n      error.statusText = result.error.statusText\n\n      if (error.statusCode === 403) {\n        await this.handle403Error()\n      }\n\n      throw error\n    }\n\n    // TODO: support sending partial response events\n    if (onConversationResponse) {\n      onConversationResponse(result.conversationResponse)\n    }\n\n    return result.response\n\n    // const lastMessage = await this.getLastMessage()\n\n    // await inputBox.focus()\n    // const paragraphs = message.split('\\n')\n    // for (let i = 0; i < paragraphs.length; i++) {\n    //   await inputBox.type(paragraphs[i], { delay: 0 })\n    //   if (i < paragraphs.length - 1) {\n    //     await this._page.keyboard.down('Shift')\n    //     await inputBox.press('Enter')\n    //     await this._page.keyboard.up('Shift')\n    //   } else {\n    //     await inputBox.press('Enter')\n    //   }\n    // }\n\n    // const responseP = new Promise<string>(async (resolve, reject) => {\n    //   try {\n    //     do {\n    //       await delay(1000)\n\n    //       // TODO: this logic needs some work because we can have repeat messages...\n    //       const newLastMessage = await this.getLastMessage()\n    //       if (\n    //         newLastMessage &&\n    //         lastMessage?.toLowerCase() !== newLastMessage?.toLowerCase()\n    //       ) {\n    //         return resolve(newLastMessage)\n    //       }\n    //     } while (true)\n    //   } catch (err) {\n    //     return reject(err)\n    //   }\n    // })\n\n    // if (timeoutMs) {\n    //   return pTimeout(responseP, {\n    //     milliseconds: timeoutMs\n    //   })\n    // } else {\n    //   return responseP\n    // }\n  }\n\n  async resetThread() {\n    try {\n      await this._page.click('nav > a:nth-child(1)')\n    } catch (err) {\n      // ignore for now\n    }\n  }\n\n  async close() {\n    await this._browser.close()\n    this._page = null\n    this._browser = null\n  }\n\n  protected async _getInputBox() {\n    // [data-id=\"root\"]\n    return this._page.$('textarea')\n  }\n}\n","import * as fs from 'node:fs'\nimport * as os from 'node:os'\n\nimport delay from 'delay'\nimport type { Browser, Page, Protocol, PuppeteerLaunchOptions } from 'puppeteer'\nimport puppeteer from 'puppeteer-extra'\nimport RecaptchaPlugin from 'puppeteer-extra-plugin-recaptcha'\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth'\n\nimport * as types from './types'\n\npuppeteer.use(StealthPlugin())\n\nlet hasRecaptchaPlugin = false\n\n/**\n * Represents everything that's required to pass into `ChatGPTAPI` in order\n * to authenticate with the unofficial ChatGPT API.\n */\nexport type OpenAIAuth = {\n  userAgent: string\n  clearanceToken: string\n  sessionToken: string\n  cookies?: Record<string, Protocol.Network.Cookie>\n}\n\n/**\n * Bypasses OpenAI's use of Cloudflare to get the cookies required to use\n * ChatGPT. Uses Puppeteer with a stealth plugin under the hood.\n *\n * If you pass `email` and `password`, then it will log into the account and\n * include a `sessionToken` in the response.\n *\n * If you don't pass `email` and `password`, then it will just return a valid\n * `clearanceToken`.\n *\n * This can be useful because `clearanceToken` expires after ~2 hours, whereas\n * `sessionToken` generally lasts much longer. We recommend renewing your\n * `clearanceToken` every hour or so and creating a new instance of `ChatGPTAPI`\n * with your updated credentials.\n */\nexport async function getOpenAIAuth({\n  email,\n  password,\n  browser,\n  page,\n  timeoutMs = 2 * 60 * 1000,\n  isGoogleLogin = false,\n  captchaToken = process.env.CAPTCHA_TOKEN,\n  executablePath\n}: {\n  email?: string\n  password?: string\n  browser?: Browser\n  page?: Page\n  timeoutMs?: number\n  isGoogleLogin?: boolean\n  captchaToken?: string\n  executablePath?: string\n}): Promise<OpenAIAuth> {\n  const origBrowser = browser\n  const origPage = page\n\n  try {\n    if (!browser) {\n      browser = await getBrowser({ captchaToken, executablePath })\n    }\n\n    const userAgent = await browser.userAgent()\n    if (!page) {\n      page = (await browser.pages())[0] || (await browser.newPage())\n      page.setDefaultTimeout(timeoutMs)\n    }\n\n    await page.goto('https://chat.openai.com/auth/login', {\n      waitUntil: 'networkidle2'\n    })\n\n    // NOTE: this is where you may encounter a CAPTCHA\n    if (hasRecaptchaPlugin) {\n      await page.solveRecaptchas()\n    }\n\n    await checkForChatGPTAtCapacity(page)\n\n    // once we get to this point, the Cloudflare cookies should be available\n\n    // login as well (optional)\n    if (email && password) {\n      await waitForConditionOrAtCapacity(page, () =>\n        page.waitForSelector('#__next .btn-primary', { timeout: timeoutMs })\n      )\n      await delay(500)\n\n      // click login button and wait for navigation to finish\n      await Promise.all([\n        page.waitForNavigation({\n          waitUntil: 'networkidle2',\n          timeout: timeoutMs\n        }),\n\n        page.click('#__next .btn-primary')\n      ])\n\n      await checkForChatGPTAtCapacity(page)\n\n      let submitP: () => Promise<void>\n\n      if (isGoogleLogin) {\n        await page.click('button[data-provider=\"google\"]')\n        await page.waitForSelector('input[type=\"email\"]')\n        await page.type('input[type=\"email\"]', email, { delay: 10 })\n        await Promise.all([\n          page.waitForNavigation(),\n          await page.keyboard.press('Enter')\n        ])\n        await page.waitForSelector('input[type=\"password\"]', { visible: true })\n        await page.type('input[type=\"password\"]', password, { delay: 10 })\n        submitP = () => page.keyboard.press('Enter')\n      } else {\n        await page.waitForSelector('#username')\n        await page.type('#username', email, { delay: 20 })\n        await delay(100)\n\n        if (hasRecaptchaPlugin) {\n          // console.log('solveRecaptchas()')\n          const res = await page.solveRecaptchas()\n          // console.log('solveRecaptchas result', res)\n        }\n\n        await page.click('button[type=\"submit\"]')\n        await page.waitForSelector('#password', { timeout: timeoutMs })\n        await page.type('#password', password, { delay: 10 })\n        submitP = () => page.click('button[type=\"submit\"]')\n      }\n\n      await Promise.all([\n        waitForConditionOrAtCapacity(page, () =>\n          page.waitForNavigation({\n            waitUntil: 'networkidle2',\n            timeout: timeoutMs\n          })\n        ),\n        submitP()\n      ])\n    } else {\n      await delay(2000)\n      await checkForChatGPTAtCapacity(page)\n    }\n\n    const pageCookies = await page.cookies()\n    const cookies = pageCookies.reduce(\n      (map, cookie) => ({ ...map, [cookie.name]: cookie }),\n      {}\n    )\n\n    const authInfo: OpenAIAuth = {\n      userAgent,\n      clearanceToken: cookies['cf_clearance']?.value,\n      sessionToken: cookies['__Secure-next-auth.session-token']?.value,\n      cookies\n    }\n\n    return authInfo\n  } catch (err) {\n    throw err\n  } finally {\n    if (origBrowser) {\n      if (page && page !== origPage) {\n        await page.close()\n      }\n    } else if (browser) {\n      await browser.close()\n    }\n\n    page = null\n    browser = null\n  }\n}\n\n/**\n * Launches a non-puppeteer instance of Chrome. Note that in my testing, I wasn't\n * able to use the built-in `puppeteer` version of Chromium because Cloudflare\n * recognizes it and blocks access.\n */\nexport async function getBrowser(\n  opts: PuppeteerLaunchOptions & {\n    captchaToken?: string\n  } = {}\n) {\n  const {\n    captchaToken = process.env.CAPTCHA_TOKEN,\n    executablePath = defaultChromeExecutablePath(),\n    ...launchOptions\n  } = opts\n\n  if (captchaToken && !hasRecaptchaPlugin) {\n    hasRecaptchaPlugin = true\n    // console.log('use captcha', captchaToken)\n\n    puppeteer.use(\n      RecaptchaPlugin({\n        provider: {\n          id: '2captcha',\n          token: captchaToken\n        },\n        visualFeedback: true // colorize reCAPTCHAs (violet = detected, green = solved)\n      })\n    )\n  }\n\n  return puppeteer.launch({\n    headless: false,\n    args: ['--no-sandbox', '--exclude-switches', 'enable-automation'],\n    ignoreHTTPSErrors: true,\n    executablePath,\n    ...launchOptions\n  })\n}\n\n/**\n * Gets the default path to chrome's executable for the current platform.\n */\nexport const defaultChromeExecutablePath = (): string => {\n  switch (os.platform()) {\n    case 'win32':\n      return 'C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe'\n\n    case 'darwin':\n      return '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'\n\n    default: {\n      /**\n       * Since two (2) separate chrome releases exist on linux, we first do a\n       * check to ensure we're executing the right one.\n       */\n      const chromeExists = fs.existsSync('/usr/bin/google-chrome')\n\n      return chromeExists\n        ? '/usr/bin/google-chrome'\n        : '/usr/bin/google-chrome-stable'\n    }\n  }\n}\n\nasync function checkForChatGPTAtCapacity(page: Page) {\n  // console.log('checkForChatGPTAtCapacity', page.url())\n  let res: any[]\n\n  try {\n    res = await page.$x(\"//div[contains(., 'ChatGPT is at capacity')]\")\n    // console.log('capacity1', els)\n    // if (els?.length) {\n    //   res = await Promise.all(\n    //     els.map((a) => a.evaluate((el) => el.textContent))\n    //   )\n    //   console.log('capacity2', res)\n    // }\n  } catch (err) {\n    // ignore errors likely due to navigation\n  }\n\n  if (res?.length) {\n    const error = new types.ChatGPTError('ChatGPT is at capacity')\n    error.statusCode = 503\n    throw error\n  }\n}\n\nasync function waitForConditionOrAtCapacity(\n  page: Page,\n  condition: () => Promise<any>,\n  opts: {\n    pollingIntervalMs?: number\n  } = {}\n) {\n  const { pollingIntervalMs = 500 } = opts\n\n  return new Promise<void>((resolve, reject) => {\n    let resolved = false\n\n    async function waitForCapacityText() {\n      if (resolved) {\n        return\n      }\n\n      try {\n        await checkForChatGPTAtCapacity(page)\n\n        if (!resolved) {\n          setTimeout(waitForCapacityText, pollingIntervalMs)\n        }\n      } catch (err) {\n        if (!resolved) {\n          resolved = true\n          return reject(err)\n        }\n      }\n    }\n\n    condition()\n      .then(() => {\n        if (!resolved) {\n          resolved = true\n          resolve()\n        }\n      })\n      .catch((err) => {\n        if (!resolved) {\n          resolved = true\n          reject(err)\n        }\n      })\n\n    setTimeout(waitForCapacityText, pollingIntervalMs)\n  })\n}\n"],"mappings":"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","names":["fetch","fetch","_a","_b","_c","_d","createParser","streamAsyncIterable","pTimeout","message","fetch","delay","uuidv4","delay","uuidv4"]}