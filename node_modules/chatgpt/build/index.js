// src/chatgpt-api.ts
import ExpiryMap from "expiry-map";
import pTimeout from "p-timeout";
import { v4 as uuidv4 } from "uuid";

// src/types.ts
var ChatGPTError = class extends Error {
};

// src/chatgpt-conversation.ts
var ChatGPTConversation = class {
  constructor(api, opts = {}) {
    this.conversationId = void 0;
    this.parentMessageId = void 0;
    this.api = api;
    this.conversationId = opts.conversationId;
    this.parentMessageId = opts.parentMessageId;
  }
  async sendMessage(message, opts = {}) {
    const { onConversationResponse, ...rest } = opts;
    return this.api.sendMessage(message, {
      ...rest,
      conversationId: this.conversationId,
      parentMessageId: this.parentMessageId,
      onConversationResponse: (response) => {
        var _a;
        if (response.conversation_id) {
          this.conversationId = response.conversation_id;
        }
        if ((_a = response.message) == null ? void 0 : _a.id) {
          this.parentMessageId = response.message.id;
        }
        if (onConversationResponse) {
          return onConversationResponse(response);
        }
      }
    });
  }
};

// src/fetch.ts
var fetch2 = globalThis.fetch;
if (typeof fetch2 !== "function") {
  throw new Error(
    "Invalid environment: global fetch not defined; `chatgpt` requires Node.js >= 18 at the moment due to Cloudflare protections"
  );
}

// src/fetch-sse.ts
import { createParser } from "eventsource-parser";

// src/stream-async-iterable.ts
async function* streamAsyncIterable(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}

// src/fetch-sse.ts
async function fetchSSE(url, options) {
  const { onMessage, ...fetchOptions } = options;
  const res = await fetch2(url, fetchOptions);
  if (!res.ok) {
    const msg = `ChatGPTAPI error ${res.status || res.statusText}`;
    const error = new ChatGPTError(msg);
    error.statusCode = res.status;
    error.statusText = res.statusText;
    error.response = res;
    throw error;
  }
  const parser = createParser((event) => {
    if (event.type === "event") {
      onMessage(event.data);
    }
  });
  if (!res.body.getReader) {
    const body = res.body;
    if (!body.on || !body.read) {
      throw new ChatGPTError('unsupported "fetch" implementation');
    }
    body.on("readable", () => {
      let chunk;
      while (null !== (chunk = body.read())) {
        parser.feed(chunk.toString());
      }
    });
  } else {
    for await (const chunk of streamAsyncIterable(res.body)) {
      const str = new TextDecoder().decode(chunk);
      parser.feed(str);
    }
  }
}

// src/utils.ts
import { remark } from "remark";
import stripMarkdown from "strip-markdown";
function markdownToText(markdown) {
  return remark().use(stripMarkdown).processSync(markdown ?? "").toString();
}
async function minimizePage(page) {
  const session = await page.target().createCDPSession();
  const goods = await session.send("Browser.getWindowForTarget");
  const { windowId } = goods;
  await session.send("Browser.setWindowBounds", {
    windowId,
    bounds: { windowState: "minimized" }
  });
}
async function maximizePage(page) {
  const session = await page.target().createCDPSession();
  const goods = await session.send("Browser.getWindowForTarget");
  const { windowId } = goods;
  await session.send("Browser.setWindowBounds", {
    windowId,
    bounds: { windowState: "normal" }
  });
}
function isRelevantRequest(url) {
  let pathname;
  try {
    const parsedUrl = new URL(url);
    pathname = parsedUrl.pathname;
    url = parsedUrl.toString();
  } catch (_) {
    return false;
  }
  if (!url.startsWith("https://chat.openai.com")) {
    return false;
  }
  if (!pathname.startsWith("/backend-api/") && !pathname.startsWith("/api/auth/session")) {
    return false;
  }
  if (pathname.endsWith("backend-api/moderations")) {
    return false;
  }
  return true;
}
async function browserPostEventStream(url, accessToken, body, timeoutMs) {
  var _a, _b, _c, _d;
  globalThis.__name = () => void 0;
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  class AbortError extends Error {
    constructor(message) {
      super();
      this.name = "AbortError";
      this.message = message;
    }
  }
  const BOM = [239, 187, 191];
  let conversationResponse;
  let conversationId = body == null ? void 0 : body.conversation_id;
  let messageId = (_b = (_a = body == null ? void 0 : body.messages) == null ? void 0 : _a[0]) == null ? void 0 : _b.id;
  let response = "";
  try {
    console.log("browserPostEventStream", url, accessToken, body);
    let abortController = null;
    if (timeoutMs) {
      abortController = new AbortController();
    }
    const res = await fetch(url, {
      method: "POST",
      body: JSON.stringify(body),
      signal: abortController == null ? void 0 : abortController.signal,
      headers: {
        accept: "text/event-stream",
        "x-openai-assistant-app-id": "",
        authorization: `Bearer ${accessToken}`,
        "content-type": "application/json"
      }
    });
    console.log("browserPostEventStream response", res);
    if (!res.ok) {
      return {
        error: {
          message: `ChatGPTAPI error ${res.status || res.statusText}`,
          statusCode: res.status,
          statusText: res.statusText
        },
        response: null,
        conversationId,
        messageId
      };
    }
    const responseP = new Promise(
      async (resolve, reject) => {
        function onMessage(data) {
          var _a2, _b2, _c2, _d2;
          if (data === "[DONE]") {
            return resolve({
              error: null,
              response,
              conversationId,
              messageId,
              conversationResponse
            });
          }
          try {
            const convoResponseEvent = JSON.parse(data);
            conversationResponse = convoResponseEvent;
            if (convoResponseEvent.conversation_id) {
              conversationId = convoResponseEvent.conversation_id;
            }
            if ((_a2 = convoResponseEvent.message) == null ? void 0 : _a2.id) {
              messageId = convoResponseEvent.message.id;
            }
            const partialResponse = (_d2 = (_c2 = (_b2 = convoResponseEvent.message) == null ? void 0 : _b2.content) == null ? void 0 : _c2.parts) == null ? void 0 : _d2[0];
            if (partialResponse) {
              response = partialResponse;
            }
          } catch (err) {
            console.warn("fetchSSE onMessage unexpected error", err);
            reject(err);
          }
        }
        const parser = createParser2((event) => {
          if (event.type === "event") {
            onMessage(event.data);
          }
        });
        for await (const chunk of streamAsyncIterable2(res.body)) {
          const str = new TextDecoder().decode(chunk);
          parser.feed(str);
        }
      }
    );
    if (timeoutMs) {
      if (abortController) {
        ;
        responseP.cancel = () => {
          abortController.abort();
        };
      }
      return await pTimeout2(responseP, {
        milliseconds: timeoutMs,
        message: "ChatGPT timed out waiting for response"
      });
    } else {
      return await responseP;
    }
  } catch (err) {
    const errMessageL = err.toString().toLowerCase();
    if (response && (errMessageL === "error: typeerror: terminated" || errMessageL === "typeerror: terminated")) {
      return {
        error: null,
        response,
        conversationId,
        messageId,
        conversationResponse
      };
    }
    return {
      error: {
        message: err.toString(),
        statusCode: err.statusCode || err.status || ((_c = err.response) == null ? void 0 : _c.statusCode),
        statusText: err.statusText || ((_d = err.response) == null ? void 0 : _d.statusText)
      },
      response: null,
      conversationId,
      messageId,
      conversationResponse
    };
  }
  async function* streamAsyncIterable2(stream) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
  function createParser2(onParse) {
    let isFirstChunk;
    let buffer;
    let startingPosition;
    let startingFieldLength;
    let eventId;
    let eventName;
    let data;
    reset();
    return { feed, reset };
    function reset() {
      isFirstChunk = true;
      buffer = "";
      startingPosition = 0;
      startingFieldLength = -1;
      eventId = void 0;
      eventName = void 0;
      data = "";
    }
    function feed(chunk) {
      buffer = buffer ? buffer + chunk : chunk;
      if (isFirstChunk && hasBom(buffer)) {
        buffer = buffer.slice(BOM.length);
      }
      isFirstChunk = false;
      const length = buffer.length;
      let position = 0;
      let discardTrailingNewline = false;
      while (position < length) {
        if (discardTrailingNewline) {
          if (buffer[position] === "\n") {
            ++position;
          }
          discardTrailingNewline = false;
        }
        let lineLength = -1;
        let fieldLength = startingFieldLength;
        let character;
        for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
          character = buffer[index];
          if (character === ":" && fieldLength < 0) {
            fieldLength = index - position;
          } else if (character === "\r") {
            discardTrailingNewline = true;
            lineLength = index - position;
          } else if (character === "\n") {
            lineLength = index - position;
          }
        }
        if (lineLength < 0) {
          startingPosition = length - position;
          startingFieldLength = fieldLength;
          break;
        } else {
          startingPosition = 0;
          startingFieldLength = -1;
        }
        parseEventStreamLine(buffer, position, fieldLength, lineLength);
        position += lineLength + 1;
      }
      if (position === length) {
        buffer = "";
      } else if (position > 0) {
        buffer = buffer.slice(position);
      }
    }
    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
      if (lineLength === 0) {
        if (data.length > 0) {
          onParse({
            type: "event",
            id: eventId,
            event: eventName || void 0,
            data: data.slice(0, -1)
          });
          data = "";
          eventId = void 0;
        }
        eventName = void 0;
        return;
      }
      const noValue = fieldLength < 0;
      const field = lineBuffer.slice(
        index,
        index + (noValue ? lineLength : fieldLength)
      );
      let step = 0;
      if (noValue) {
        step = lineLength;
      } else if (lineBuffer[index + fieldLength + 1] === " ") {
        step = fieldLength + 2;
      } else {
        step = fieldLength + 1;
      }
      const position = index + step;
      const valueLength = lineLength - step;
      const value = lineBuffer.slice(position, position + valueLength).toString();
      if (field === "data") {
        data += value ? `${value}
` : "\n";
      } else if (field === "event") {
        eventName = value;
      } else if (field === "id" && !value.includes("\0")) {
        eventId = value;
      } else if (field === "retry") {
        const retry = parseInt(value, 10);
        if (!Number.isNaN(retry)) {
          onParse({ type: "reconnect-interval", value: retry });
        }
      }
    }
  }
  function hasBom(buffer) {
    return BOM.every(
      (charCode, index) => buffer.charCodeAt(index) === charCode
    );
  }
  function getDOMException(errorMessage) {
    return globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
  }
  function getAbortedReason(signal) {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  }
  function pTimeout2(promise, options) {
    const {
      milliseconds,
      fallback,
      message,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(
          `Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``
        );
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve(promise);
        return;
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      timer = customTimers.setTimeout.call(
        void 0,
        () => {
          if (fallback) {
            try {
              resolve(fallback());
            } catch (error) {
              reject(error);
            }
            return;
          }
          const errorMessage = typeof message === "string" ? message : `Promise timed out after ${milliseconds} milliseconds`;
          const timeoutError = message instanceof Error ? message : new TimeoutError(errorMessage);
          if (typeof promise.cancel === "function") {
            ;
            promise.cancel();
          }
          reject(timeoutError);
        },
        milliseconds
      );
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        } finally {
          customTimers.clearTimeout.call(void 0, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }
}

// src/chatgpt-api.ts
var KEY_ACCESS_TOKEN = "accessToken";
var USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36";
var ChatGPTAPI = class {
  constructor(opts) {
    this._user = null;
    const {
      sessionToken,
      clearanceToken,
      markdown = true,
      apiBaseUrl = "https://chat.openai.com/api",
      backendApiBaseUrl = "https://chat.openai.com/backend-api",
      userAgent = USER_AGENT,
      accessTokenTTL = 60 * 6e4,
      accessToken,
      headers,
      debug = false
    } = opts;
    this._sessionToken = sessionToken;
    this._clearanceToken = clearanceToken;
    this._markdown = !!markdown;
    this._debug = !!debug;
    this._apiBaseUrl = apiBaseUrl;
    this._backendApiBaseUrl = backendApiBaseUrl;
    this._userAgent = userAgent;
    this._headers = {
      "user-agent": this._userAgent,
      "x-openai-assistant-app-id": "",
      "accept-language": "en-US,en;q=0.9",
      "accept-encoding": "gzip, deflate, br",
      origin: "https://chat.openai.com",
      referer: "https://chat.openai.com/chat",
      "sec-ch-ua": '"Not?A_Brand";v="8", "Chromium";v="108", "Google Chrome";v="108"',
      "sec-ch-ua-platform": '"macOS"',
      "sec-fetch-dest": "empty",
      "sec-fetch-mode": "cors",
      "sec-fetch-site": "same-origin",
      ...headers
    };
    this._accessTokenCache = new ExpiryMap(accessTokenTTL);
    if (accessToken) {
      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken);
    }
    if (!this._sessionToken) {
      throw new ChatGPTError("ChatGPT invalid session token");
    }
    if (!this._clearanceToken) {
      throw new ChatGPTError("ChatGPT invalid clearance token");
    }
  }
  get user() {
    return this._user;
  }
  get sessionToken() {
    return this._sessionToken;
  }
  get clearanceToken() {
    return this._clearanceToken;
  }
  get userAgent() {
    return this._userAgent;
  }
  async sendMessage(message, opts = {}) {
    const {
      conversationId,
      parentMessageId = uuidv4(),
      messageId = uuidv4(),
      action = "next",
      timeoutMs,
      onProgress,
      onConversationResponse
    } = opts;
    let { abortSignal } = opts;
    let abortController = null;
    if (timeoutMs && !abortSignal) {
      abortController = new AbortController();
      abortSignal = abortController.signal;
    }
    const accessToken = await this.refreshAccessToken();
    const body = {
      action,
      messages: [
        {
          id: messageId,
          role: "user",
          content: {
            content_type: "text",
            parts: [message]
          }
        }
      ],
      model: "text-davinci-002-render",
      parent_message_id: parentMessageId
    };
    if (conversationId) {
      body.conversation_id = conversationId;
    }
    let response = "";
    const responseP = new Promise((resolve, reject) => {
      const url = `${this._backendApiBaseUrl}/conversation`;
      const headers = {
        ...this._headers,
        Authorization: `Bearer ${accessToken}`,
        Accept: "text/event-stream",
        "Content-Type": "application/json",
        Cookie: `cf_clearance=${this._clearanceToken}`
      };
      if (this._debug) {
        console.log("POST", url, { body, headers });
      }
      fetchSSE(url, {
        method: "POST",
        headers,
        body: JSON.stringify(body),
        signal: abortSignal,
        onMessage: (data) => {
          var _a, _b;
          if (data === "[DONE]") {
            return resolve(response);
          }
          try {
            const parsedData = JSON.parse(data);
            if (onConversationResponse) {
              onConversationResponse(parsedData);
            }
            const message2 = parsedData.message;
            if (message2) {
              let text = (_b = (_a = message2 == null ? void 0 : message2.content) == null ? void 0 : _a.parts) == null ? void 0 : _b[0];
              if (text) {
                if (!this._markdown) {
                  text = markdownToText(text);
                }
                response = text;
                if (onProgress) {
                  onProgress(text);
                }
              }
            }
          } catch (err) {
            console.warn("fetchSSE onMessage unexpected error", err);
            reject(err);
          }
        }
      }).catch((err) => {
        const errMessageL = err.toString().toLowerCase();
        if (response && (errMessageL === "error: typeerror: terminated" || errMessageL === "typeerror: terminated")) {
          return resolve(response);
        } else {
          return reject(err);
        }
      });
    });
    if (timeoutMs) {
      if (abortController) {
        ;
        responseP.cancel = () => {
          abortController.abort();
        };
      }
      return pTimeout(responseP, {
        milliseconds: timeoutMs,
        message: "ChatGPT timed out waiting for response"
      });
    } else {
      return responseP;
    }
  }
  async sendModeration(input) {
    const accessToken = await this.refreshAccessToken();
    const url = `${this._backendApiBaseUrl}/moderations`;
    const headers = {
      ...this._headers,
      Authorization: `Bearer ${accessToken}`,
      Accept: "*/*",
      "Content-Type": "application/json",
      Cookie: `cf_clearance=${this._clearanceToken}`
    };
    const body = {
      input,
      model: "text-moderation-playground"
    };
    if (this._debug) {
      console.log("POST", url, headers, body);
    }
    const res = await fetch2(url, {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    }).then((r) => {
      if (!r.ok) {
        const error = new ChatGPTError(`${r.status} ${r.statusText}`);
        error.response = r;
        error.statusCode = r.status;
        error.statusText = r.statusText;
        throw error;
      }
      return r.json();
    });
    return res;
  }
  async getIsAuthenticated() {
    try {
      void await this.refreshAccessToken();
      return true;
    } catch (err) {
      return false;
    }
  }
  async ensureAuth() {
    return await this.refreshAccessToken();
  }
  async refreshAccessToken() {
    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN);
    if (cachedAccessToken) {
      return cachedAccessToken;
    }
    let response;
    try {
      const url = `${this._apiBaseUrl}/auth/session`;
      const headers = {
        ...this._headers,
        cookie: `cf_clearance=${this._clearanceToken}; __Secure-next-auth.session-token=${this._sessionToken}`,
        accept: "*/*"
      };
      if (this._debug) {
        console.log("GET", url, headers);
      }
      const res = await fetch2(url, {
        headers
      }).then((r) => {
        response = r;
        if (!r.ok) {
          const error = new ChatGPTError(`${r.status} ${r.statusText}`);
          error.response = r;
          error.statusCode = r.status;
          error.statusText = r.statusText;
          throw error;
        }
        return r.json();
      });
      const accessToken = res == null ? void 0 : res.accessToken;
      if (!accessToken) {
        const error = new ChatGPTError("Unauthorized");
        error.response = response;
        error.statusCode = response == null ? void 0 : response.status;
        error.statusText = response == null ? void 0 : response.statusText;
        throw error;
      }
      const appError = res == null ? void 0 : res.error;
      if (appError) {
        if (appError === "RefreshAccessTokenError") {
          const error = new ChatGPTError("session token may have expired");
          error.response = response;
          error.statusCode = response == null ? void 0 : response.status;
          error.statusText = response == null ? void 0 : response.statusText;
          throw error;
        } else {
          const error = new ChatGPTError(appError);
          error.response = response;
          error.statusCode = response == null ? void 0 : response.status;
          error.statusText = response == null ? void 0 : response.statusText;
          throw error;
        }
      }
      if (res.user) {
        this._user = res.user;
      }
      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken);
      return accessToken;
    } catch (err) {
      if (this._debug) {
        console.error(err);
      }
      const error = new ChatGPTError(
        `ChatGPT failed to refresh auth token. ${err.toString()}`
      );
      error.response = response;
      error.statusCode = response == null ? void 0 : response.status;
      error.statusText = response == null ? void 0 : response.statusText;
      error.originalError = err;
      throw error;
    }
  }
  getConversation(opts = {}) {
    return new ChatGPTConversation(this, opts);
  }
};

// src/chatgpt-api-browser.ts
import delay2 from "delay";
import { v4 as uuidv42 } from "uuid";

// src/openai-auth.ts
import * as fs from "node:fs";
import * as os from "node:os";
import delay from "delay";
import puppeteer from "puppeteer-extra";
import RecaptchaPlugin from "puppeteer-extra-plugin-recaptcha";
import StealthPlugin from "puppeteer-extra-plugin-stealth";
puppeteer.use(StealthPlugin());
var hasRecaptchaPlugin = false;
async function getOpenAIAuth({
  email,
  password,
  browser,
  page,
  timeoutMs = 2 * 60 * 1e3,
  isGoogleLogin = false,
  captchaToken = process.env.CAPTCHA_TOKEN,
  executablePath
}) {
  var _a, _b;
  const origBrowser = browser;
  const origPage = page;
  try {
    if (!browser) {
      browser = await getBrowser({ captchaToken, executablePath });
    }
    const userAgent = await browser.userAgent();
    if (!page) {
      page = (await browser.pages())[0] || await browser.newPage();
      page.setDefaultTimeout(timeoutMs);
    }
    await page.goto("https://chat.openai.com/auth/login", {
      waitUntil: "networkidle2"
    });
    if (hasRecaptchaPlugin) {
      await page.solveRecaptchas();
    }
    await checkForChatGPTAtCapacity(page);
    if (email && password) {
      await waitForConditionOrAtCapacity(
        page,
        () => page.waitForSelector("#__next .btn-primary", { timeout: timeoutMs })
      );
      await delay(500);
      await Promise.all([
        page.waitForNavigation({
          waitUntil: "networkidle2",
          timeout: timeoutMs
        }),
        page.click("#__next .btn-primary")
      ]);
      await checkForChatGPTAtCapacity(page);
      let submitP;
      if (isGoogleLogin) {
        await page.click('button[data-provider="google"]');
        await page.waitForSelector('input[type="email"]');
        await page.type('input[type="email"]', email, { delay: 10 });
        await Promise.all([
          page.waitForNavigation(),
          await page.keyboard.press("Enter")
        ]);
        await page.waitForSelector('input[type="password"]', { visible: true });
        await page.type('input[type="password"]', password, { delay: 10 });
        submitP = () => page.keyboard.press("Enter");
      } else {
        await page.waitForSelector("#username");
        await page.type("#username", email, { delay: 20 });
        await delay(100);
        if (hasRecaptchaPlugin) {
          const res = await page.solveRecaptchas();
        }
        await page.click('button[type="submit"]');
        await page.waitForSelector("#password", { timeout: timeoutMs });
        await page.type("#password", password, { delay: 10 });
        submitP = () => page.click('button[type="submit"]');
      }
      await Promise.all([
        waitForConditionOrAtCapacity(
          page,
          () => page.waitForNavigation({
            waitUntil: "networkidle2",
            timeout: timeoutMs
          })
        ),
        submitP()
      ]);
    } else {
      await delay(2e3);
      await checkForChatGPTAtCapacity(page);
    }
    const pageCookies = await page.cookies();
    const cookies = pageCookies.reduce(
      (map, cookie) => ({ ...map, [cookie.name]: cookie }),
      {}
    );
    const authInfo = {
      userAgent,
      clearanceToken: (_a = cookies["cf_clearance"]) == null ? void 0 : _a.value,
      sessionToken: (_b = cookies["__Secure-next-auth.session-token"]) == null ? void 0 : _b.value,
      cookies
    };
    return authInfo;
  } catch (err) {
    throw err;
  } finally {
    if (origBrowser) {
      if (page && page !== origPage) {
        await page.close();
      }
    } else if (browser) {
      await browser.close();
    }
    page = null;
    browser = null;
  }
}
async function getBrowser(opts = {}) {
  const {
    captchaToken = process.env.CAPTCHA_TOKEN,
    executablePath = defaultChromeExecutablePath(),
    ...launchOptions
  } = opts;
  if (captchaToken && !hasRecaptchaPlugin) {
    hasRecaptchaPlugin = true;
    puppeteer.use(
      RecaptchaPlugin({
        provider: {
          id: "2captcha",
          token: captchaToken
        },
        visualFeedback: true
      })
    );
  }
  return puppeteer.launch({
    headless: false,
    args: ["--no-sandbox", "--exclude-switches", "enable-automation"],
    ignoreHTTPSErrors: true,
    executablePath,
    ...launchOptions
  });
}
var defaultChromeExecutablePath = () => {
  switch (os.platform()) {
    case "win32":
      return "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe";
    case "darwin":
      return "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
    default: {
      const chromeExists = fs.existsSync("/usr/bin/google-chrome");
      return chromeExists ? "/usr/bin/google-chrome" : "/usr/bin/google-chrome-stable";
    }
  }
};
async function checkForChatGPTAtCapacity(page) {
  let res;
  try {
    res = await page.$x("//div[contains(., 'ChatGPT is at capacity')]");
  } catch (err) {
  }
  if (res == null ? void 0 : res.length) {
    const error = new ChatGPTError("ChatGPT is at capacity");
    error.statusCode = 503;
    throw error;
  }
}
async function waitForConditionOrAtCapacity(page, condition, opts = {}) {
  const { pollingIntervalMs = 500 } = opts;
  return new Promise((resolve, reject) => {
    let resolved = false;
    async function waitForCapacityText() {
      if (resolved) {
        return;
      }
      try {
        await checkForChatGPTAtCapacity(page);
        if (!resolved) {
          setTimeout(waitForCapacityText, pollingIntervalMs);
        }
      } catch (err) {
        if (!resolved) {
          resolved = true;
          return reject(err);
        }
      }
    }
    condition().then(() => {
      if (!resolved) {
        resolved = true;
        resolve();
      }
    }).catch((err) => {
      if (!resolved) {
        resolved = true;
        reject(err);
      }
    });
    setTimeout(waitForCapacityText, pollingIntervalMs);
  });
}

// src/chatgpt-api-browser.ts
var ChatGPTAPIBrowser = class {
  constructor(opts) {
    this._onRequest = (request) => {
      const url = request.url();
      if (!isRelevantRequest(url)) {
        return;
      }
      const method = request.method();
      let body;
      if (method === "POST") {
        body = request.postData();
        try {
          body = JSON.parse(body);
        } catch (_) {
        }
      }
      if (this._debug) {
        console.log("\nrequest", {
          url,
          method,
          headers: request.headers(),
          body
        });
      }
    };
    this._onResponse = async (response) => {
      const request = response.request();
      const url = response.url();
      if (!isRelevantRequest(url)) {
        return;
      }
      const status = response.status();
      let body;
      try {
        body = await response.json();
      } catch (_) {
      }
      if (this._debug) {
        console.log("\nresponse", {
          url,
          ok: response.ok(),
          status,
          statusText: response.statusText(),
          headers: response.headers(),
          body,
          request: {
            method: request.method(),
            headers: request.headers(),
            body: request.postData()
          }
        });
      }
      if (url.endsWith("/conversation")) {
        if (status === 403) {
          await this.handle403Error();
        }
      } else if (url.endsWith("api/auth/session")) {
        if (status === 403) {
          await this.handle403Error();
        } else {
          const session = body;
          if (session == null ? void 0 : session.accessToken) {
            this._accessToken = session.accessToken;
          }
        }
      }
    };
    const {
      email,
      password,
      markdown = true,
      debug = false,
      isGoogleLogin = false,
      minimize = true,
      captchaToken,
      executablePath
    } = opts;
    this._email = email;
    this._password = password;
    this._markdown = !!markdown;
    this._debug = !!debug;
    this._isGoogleLogin = !!isGoogleLogin;
    this._minimize = !!minimize;
    this._captchaToken = captchaToken;
    this._executablePath = executablePath;
  }
  async init() {
    if (this._browser) {
      await this._browser.close();
      this._page = null;
      this._browser = null;
      this._accessToken = null;
    }
    try {
      this._browser = await getBrowser({
        captchaToken: this._captchaToken,
        executablePath: this._executablePath
      });
      this._page = (await this._browser.pages())[0] || await this._browser.newPage();
      await maximizePage(this._page);
      this._page.on("request", this._onRequest.bind(this));
      this._page.on("response", this._onResponse.bind(this));
      await getOpenAIAuth({
        email: this._email,
        password: this._password,
        browser: this._browser,
        page: this._page,
        isGoogleLogin: this._isGoogleLogin
      });
    } catch (err) {
      if (this._browser) {
        await this._browser.close();
      }
      this._browser = null;
      this._page = null;
      throw err;
    }
    const chatUrl = "https://chat.openai.com/chat";
    const url = this._page.url().replace(/\/$/, "");
    if (url !== chatUrl) {
      await this._page.goto(chatUrl, {
        waitUntil: "networkidle2"
      });
    }
    do {
      const modalSelector = '[data-headlessui-state="open"]';
      if (!await this._page.$(modalSelector)) {
        break;
      }
      try {
        await this._page.click(`${modalSelector} button:last-child`);
      } catch (err) {
        break;
      }
      await delay2(300);
    } while (true);
    if (!this.getIsAuthenticated()) {
      return false;
    }
    if (this._minimize) {
      await minimizePage(this._page);
    }
    return true;
  }
  async handle403Error() {
    console.log(`ChatGPT "${this._email}" session expired; refreshing...`);
    try {
      await maximizePage(this._page);
      await this._page.reload({
        waitUntil: "networkidle2",
        timeout: 2 * 60 * 1e3
      });
      if (this._minimize) {
        await minimizePage(this._page);
      }
    } catch (err) {
      console.error(
        `ChatGPT "${this._email}" error refreshing session`,
        err.toString()
      );
    }
  }
  async getIsAuthenticated() {
    try {
      const inputBox = await this._getInputBox();
      return !!inputBox;
    } catch (err) {
      return false;
    }
  }
  async sendMessage(message, opts = {}) {
    const {
      conversationId,
      parentMessageId = uuidv42(),
      messageId = uuidv42(),
      action = "next",
      timeoutMs,
      onConversationResponse
    } = opts;
    const inputBox = await this._getInputBox();
    if (!inputBox || !this._accessToken) {
      console.log(`chatgpt re-authenticating ${this._email}`);
      let isAuthenticated = false;
      try {
        isAuthenticated = await this.init();
      } catch (err) {
        console.warn(
          `chatgpt error re-authenticating ${this._email}`,
          err.toString()
        );
      }
      if (!isAuthenticated || !this._accessToken) {
        const error = new ChatGPTError("Not signed in");
        error.statusCode = 401;
        throw error;
      }
    }
    const url = `https://chat.openai.com/backend-api/conversation`;
    const body = {
      action,
      messages: [
        {
          id: messageId,
          role: "user",
          content: {
            content_type: "text",
            parts: [message]
          }
        }
      ],
      model: "text-davinci-002-render",
      parent_message_id: parentMessageId
    };
    if (conversationId) {
      body.conversation_id = conversationId;
    }
    const result = await this._page.evaluate(
      browserPostEventStream,
      url,
      this._accessToken,
      body,
      timeoutMs
    );
    if (result.error) {
      const error = new ChatGPTError(result.error.message);
      error.statusCode = result.error.statusCode;
      error.statusText = result.error.statusText;
      if (error.statusCode === 403) {
        await this.handle403Error();
      }
      throw error;
    }
    if (onConversationResponse) {
      onConversationResponse(result.conversationResponse);
    }
    return result.response;
  }
  async resetThread() {
    try {
      await this._page.click("nav > a:nth-child(1)");
    } catch (err) {
    }
  }
  async close() {
    await this._browser.close();
    this._page = null;
    this._browser = null;
  }
  async _getInputBox() {
    return this._page.$("textarea");
  }
};
export {
  ChatGPTAPI,
  ChatGPTAPIBrowser,
  ChatGPTConversation,
  ChatGPTError,
  browserPostEventStream,
  defaultChromeExecutablePath,
  getBrowser,
  getOpenAIAuth,
  isRelevantRequest,
  markdownToText,
  maximizePage,
  minimizePage
};
//# sourceMappingURL=index.js.map